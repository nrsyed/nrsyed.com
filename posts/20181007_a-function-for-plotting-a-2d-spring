In the past, I've found myself having to (or, at least, really wanting to) draw and animate a clean-looking 2D spring between any two arbitrary points. <a href="https://nrsyed.com/2018/01/07/numerical-approach-to-studying-vehicle-dynamics-with-a-half-car-suspension-model/">This post from January</a>, in which I represented the suspension struts of a car with 2D springs in matplotlib, is a notable example. Unable to find a good existing tool for plotting a spring, I decided to make my own. Here's a demo of it in action:

<iframe width="560" height="315" src="https://www.youtube.com/embed/Y70-afmGeh4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

If you're electronically inclined, it doubles as a resistor symbol (though I don't think a resistor that extends and compresses is what they mean by "variable resistor").

The code for the <code>spring()</code> function that produces the x and y coordinates of each point of the spring <a href="https://github.com/nrsyed/utilities/tree/master/spring" rel="noopener" target="_blank">can be found on my Github</a>.

<h1>The math</h1>
If a picture is worth a thousand words, an equation must be worth at least a hundred. In this section, we'll combine the two to briefly examine how the function works. First, let's define the spring as a sawtooth-shaped set of lines between two endpoints. Because this looks like a series of points or nodes connected by lines, I've elected to refer to the points as "nodes" (each node can be thought of as a spring coil).

<img src="https://nrsyed.com/wp-content/uploads/2018/10/spr_nodes.png" alt="" width="762" height="329" class="alignnone size-full wp-image-735" />

We'll use [latex]n[/latex] to describe the number of nodes between the two endpoints (counting the endpoints, any given spring will have [latex]n+2[/latex] nodes numbered from [latex]0[/latex] to [latex]n+1[/latex]). The figure above shows what springs with [latex]n=1[/latex], [latex]n=2[/latex], and [latex]n=3[/latex] nodes look like and how the nodes are numbered (node [latex]0[/latex] is the first endpoint and node [latex]n+1[/latex] is the other endpoint). These figures illustrate the case where both endpoints are aligned vertically for simplicity, but the endpoints can be anywhere in space.

Observe the pattern in the figure above—starting at node [latex]0[/latex], the next node is offset some perpendicular distance from the imaginary centerline between the endpoints and some parallel distance along the centerline; the node after that is offset the same perpendicular distance in the other direction and some multiple of the parallel distance along the centerline. Here's what that centerline would look like for each example:

<img src="https://nrsyed.com/wp-content/uploads/2018/10/spr_centerlines.png" alt="" width="588" height="266" class="alignnone size-full wp-image-740" />

Next, let's define the distance, or length, between the two endpoints as [latex]l[/latex], i.e., the length of the centerline.

<img src="https://nrsyed.com/wp-content/uploads/2018/10/spr_length.png" alt="" width="706" height="313" class="alignnone size-full wp-image-733" />

Using this distance and the aforementioned pattern, the following relationship based on the distance [latex]l[/latex] between the endpoints and the number of nodes [latex]n[/latex] between the endpoints emerges:

<img src="https://nrsyed.com/wp-content/uploads/2018/10/spr_node_dist.png" alt="" width="531" height="305" class="alignnone size-full wp-image-734" />

In this figure, [latex]n=1[/latex] and [latex]n=2[/latex] are used as representative examples, but the same pattern can be observed for any values of [latex]l[/latex] and [latex]n[/latex]. After the root node (node [latex]0[/latex]), each subsequent node [latex]i[/latex] is located a specific distance along the centerline, given by the following expression:

<span id="eqn1">\[ (d_i)_{\parallel} = \frac{l}{2n}(2i - 1) \hspace{2em} \textbf{(Equation 1)} \]</span>

where [latex](d_i)_{\parallel}[/latex] refers to the distance of the [latex]i\mathrm{th}[/latex] node along (parallel to) the centerline, excluding the endpoints. In other words, node [latex]1[/latex] is located a distance [latex]\displaystyle\frac{l}{2n}(2(1)-1) = \frac{l}{2n}[/latex] along the centerline, node [latex]2[/latex] is located a distance [latex]\displaystyle\frac{l}{2n}(2(2)-1) = \frac{3l}{2n}[/latex] along the centerline, and so on.

<img src="https://nrsyed.com/wp-content/uploads/2018/10/spr_width.png" alt="" width="331" height="720" class="alignleft size-full wp-image-738" />
Now, let's define the width [latex]w[/latex] of the spring, which is essentially the length of each full line between nodes and can also be thought of as the diameter of the spring. This is, perhaps, best illustrated by the figure adjacent, which shows how each "link" in the spring moves as the spring compresses or extends. When the spring is fully compressed, i.e., when the two endpoints are on top of each other, [latex]w[/latex] is the width (or diameter) of the spring, at which position the nodes (not counting the endpoints) are a perpendicular distance [latex]\displaystyle \frac{w}{2}[/latex] from the center of the spring.

Because [latex]w[/latex] is fixed, the actual perpendicular distance of each node from the centerline of the spring will be lower when the spring is stretched. The actual distance can be determined using the Pythagorean theorem, shown in the figure below.

<img src="https://nrsyed.com/wp-content/uploads/2018/10/spr_normal_dist.png" alt="" width="582" height="284" class="alignnone size-full wp-image-736" />

In the figure above, I've shown the right-triangle relationship for both an entire line and for half a line. We really only care about the half-line, since we want the perpendicular distance of each node from the centerline, not from the previous node. Again, observe the pattern. Each node will be a perpendicular distance [latex]\displaystyle \frac{1}{2} \sqrt{w^2 - \frac{l^2}{n^2}}[/latex] from the centerline, alternating between the two sides of the centerline. In other words:

<span id="eqn2">\[ (d_i)_{\perp} = \frac{1}{2}\sqrt{w^2 - \frac{l^2}{n^2}}(-1)^i \hspace{2em} \textbf{(Equation 2)} \]</span>

where [latex](d_i)_{\perp}[/latex] is the distance of the [latex]i\mathrm{th}[/latex] node from (perpendicular to) the centerline, excluding the endpoints.

There's a potential pitfall here if we're not careful—notice that the spring can extend to a maximum length of [latex]nw[/latex], at which point it would just be a straight line. If [latex]l > nw[/latex], the spring can't physically attain the necessary length because the quantity inside the square root [latex] \sqrt{w^2 - \frac{l^2}{n^2}}[/latex] is negative.

The last step involves computing the unit vectors tangent (parallel) to and normal (perpendicular) to the centerline between the endpoints in order to generate a spring between any two arbitrary endpoints, regardless of how they're oriented in space:

<img src="https://nrsyed.com/wp-content/uploads/2018/10/spr_unit_vectors.png" alt="" width="274" height="285" class="aligncenter size-full wp-image-737" />

The unit tangent (parallel) vector is computed as the difference of the positions of the two endpoints divided by the distance between them:

<span id="eqn3">\[ \hat{\pmb{u}}_t = \frac{\pmb{r}_{n+1} - \pmb{r}_0}{l} \hspace{2em} \textbf{(Equation 3)} \]</span>

where [latex]\pmb{r}_0[/latex] is the position (x and y coordinates) of the first endpoint, [latex]\pmb{r}_{n+1}[/latex] is the position of the second endpoint, and [latex]l[/latex] is the previously defined distance between them, i.e., [latex]l = \| \pmb{r}_{n+1} - \pmb{r}_0 \|[/latex].

To obtain [latex]\hat{\pmb{u}}_n[/latex], which is perpendicular to [latex]\hat{\pmb{u}}_t[/latex], we can simply swap the x and y coordinates of [latex]\hat{\pmb{u}}_t[/latex] and arbitrarily negate one of them. Because I have a potentially unhealthy appreciation for linear algebra, we can write this as follows with a simple 2x2 matrix:

<span id="eqn4">\[ \hat{\pmb{u}}_n = \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix} \hat{\pmb{u}}_t \hspace{2em} \textbf{(Equation 4)} \]</span>

Finally, to obtain the absolute position of each node between the endpoints, we combine <a href="#eqn1">Equation 1</a>, <a href="#eqn2">Equation 2</a>, <a href="#eqn3">Equation 3</a>, and <a href="#eqn4">Equation 4</a> and add them to the position of the first endpoint:

<span id="eqn5">\[ \pmb{r}_i = \pmb{r}_0 + \frac{l}{2n}(2i-1)\hat{\pmb{u}}_t + \frac{1}{2}\sqrt{w^2 - \frac{l^2}{n^2}}(-1)^i \hat{\pmb{u}}_n \hspace{2em} \textbf{(Equation 5)} \]</span>

<h1>The code</h1>

The code <a href="https://github.com/nrsyed/utilities/tree/master/spring" rel="noopener" target="_blank">can be found on Github</a>. The <code>spring()</code> function takes the arguments <code>start</code> (the first endpoint [latex]\pmb{r}_0[/latex]), <code>end</code> (the second endpoint [latex]\pmb{r}_{n+1}[/latex]), <code>nodes</code> (the number of intermediate nodes [latex]n[/latex]), and <code>width</code> (the width [latex]w[/latex]). <code>start</code> and <code>end</code> may be 2-tuples, or numpy arrays of 2 elements, etc.

<pre class="line-numbers" data-start=4><code class="language-python">def spring(start, end, nodes, width):
    """!
    Return a list of points corresponding to a spring.
    @param r1 (array-like) The (x, y) coordinates of the first endpoint.
    @param r2 (array-like) The (x, y) coordinates of the second endpoint.
    @param nodes (int) The number of spring "nodes" or coils.
    @param width (int or float) The diameter of the spring.
    @return An array of x coordinates and an array of y coordinates.
    """</code></pre>

<strong>Line 16</strong> ensures that a positive non-zero integer number of nodes is chosen.

<pre class="line-numbers" data-start=16><code class="language-python">nodes = max(int(nodes), 1)</code></pre>

After computing the length and the tangent and normal unit vectors, we'll initialize a [latex]2 \times (n+2)[/latex] numpy array of all the points in sequence, where the first row corresponds to the x coordinates, the second to the y coordinates, and each column to a point. The first endpoint is assigned to the first column and the other endpoint is assigned to the last column.

<pre class="line-numbers" data-start=30><code class="language-python">    spring_coords = np.zeros((2, nodes + 2))
    spring_coords[:,0], spring_coords[:,-1] = start, end</code></pre>

On <strong>line 36</strong>, the magnitude of the normal (perpendicular) distance of the nodes from the centerline, from <a href="#eqn2">Equation 2</a>, is calculated, taking care to account for the case where the quantity in the square root is negative, in which case the value is set to 0, forming a straight line.

<pre class="line-numbers" data-start=36><code class="language-python">    normal_dist = math.sqrt(max(0, width**2 - (length**2 / nodes**2))) / 2</code></pre>

Lastly, we iterate through nodes [latex]1[/latex] to [latex]n[/latex], applying <a href="#eqn5">Equation 5</a> to compute the coordinates of each point.

<pre class="line-numbers" data-start=39><code class="language-python">    for i in range(1, nodes + 1):
        spring_coords[:,i] = (
            start
            + ((length * (2 * i - 1) * u_t) / (2 * nodes))
            + (normal_dist * (-1)**i * u_n))

    return spring_coords[0,:], spring_coords[1,:]</code></pre>

I've opted to return each row (x coordinates and y coordinates) separately, making it easy to feed the output of the function to <code>matplotlib.pyplot.plot()</code> or to the <code>set_data()</code> method of an existing matplotlib <code>Line2D</code> object on each iteration of an animation.

Hope you've found this post or the tool to be helpful!
