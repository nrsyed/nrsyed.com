In this and the next couple posts, we'll talk about inverse kinematics—specifically, the Jacobian inverse method. Although a firm grasp of multivariable calculus is necessary to fully appreciate this method, <strong>you do not need to know calculus to read these posts!</strong> I will touch on some of the theory, but as long as you have a basic understanding of <a href="https://simple.wikipedia.org/wiki/Differential_calculus" rel="noopener" target="_blank">what a derivative represents</a>, you should be fine. That said, you will need to have a solid handle on <a href="https://en.wikipedia.org/wiki/Euclidean_vector" rel="noopener" target="_blank">vectors</a>, <a href="https://en.wikipedia.org/wiki/Matrix_(mathematics)" rel="noopener" target="_blank">matrices and matrix multiplication</a>, and <a href="https://en.wikipedia.org/wiki/Cross_product" rel="noopener" target="_blank">cross products</a>. You should also understand how Euclidean transformation matrices work, which I discussed in <a href="https://nrsyed.com/2017/12/03/euclidean-transformation-matrices/" rel="noopener" target="_blank">a previous post</a>.

This post will cover the setup and the basic kinematic equations of our system. The next post will discuss the meat of the Jacobian inverse approach, i.e., the Jacobian matrix and its inverse.

<h1>What is inverse kinematics?</h1>
In broad terms, inverse kinematics is a technique that allows us to determine how to move something from one position to another position. When you want to reach for a glass of water on a table, your brain is essentially performing a sophisticated form of inverse kinematics to figure out how to rotate your shoulder joint, elbow joint, and wrist to move your hand toward the glass. In robotics, inverse kinematics is frequently employed for control of robot arms.

The "inverse" in "inverse kinematics" refers to the idea that it's the opposite of "forward kinematics."
<br>
<img src="https://nrsyed.com/wp-content/uploads/2017/12/ik_vs_fk.jpg" alt="" width="500" height="312" class="alignnone" />

Suppose we have a 2D robot arm consisting of several revolute joints (the solid green circles in the image above) leading up to an end effector (the empty circle in the image above). The end effector might be a gripper or some other sort of robotic manipulator. Each joint is defined by a joint angle, denoted by <i>θ<sub>i</sub></i>, and the end effector is located someplace in physical space, denoted by the position vector <b>r<sub>e</sub></b>. Forward kinematics asks, "if we know the joint angles, what are the coordinates <b>r<sub>e</sub></b> of the end effector?" On the other hand, inverse kinematics asks, "if we have a desired end effector position <b>r<sub>e</sub></b> in mind, what are the joint angles needed to achieve that position?"

Unlike forward kinematics, the answer to the inverse kinematics question is complicated by the fact that it does not always have a single solution.
<br>
<img src="https://nrsyed.com/wp-content/uploads/2017/12/ik_multiple_solutions.jpg" alt="" width="500" height="229" class="alignnone" />

There are usually several orientations, or "poses," that allow the system to reach the same target end effector position. To further examine this, we must first decide how to describe our robot arm mathematically.

<h1>Defining coordinate systems</h1>
We'll be dealing with multiple rotating segments, so it makes sense to define a coordinate system for each joint/segment.

<img src="https://nrsyed.com/wp-content/uploads/2017/12/ik_coordinate_systems.jpg" alt="" width="500" height="259" class="alignnone" />
<br>
Each joint will serve as the origin for its coordinate system, e.g., <i>X<sub>1</sub>Y<sub>1</sub></i> is the coordinate system for the first joint, where the <i>X<sub>1</sub></i> axis is coincident with the first link, which has a length <i>L<sub>1</sub></i>. The angle of the first link, i.e., the amount by which the first joint is rotated relative to the global coordinate system, is given by <i>θ<sub>1</sub></i>. Similarly, the second joint is the origin for the second coordinate system, <i>X<sub>2</sub>Y<sub>2</sub></i>, which is rotated by an angle <i>θ<sub>2</sub></i> relative to the first coordinate system.

Going from one coordinate system to another can be achieved with transformation matrices. Each joint will have its own transformation matrix. The transformation matrices will allow us to get the coordinates of the end effector in terms of the global coordinate system, which we'll call the <i>X<sub>0</sub>Y<sub>0</sub></i> system, based on the joint angles and the length of each link.

Even though our robot arm lies in the <i>XY</i> plane, we're going to use 3D vectors and 4x4 transformation matrices, not only because we'll be dealing with cross products, but also because it will help us develop a more general formulation of the inverse kinematics equations. Really, I should be using the notation <i>X<sub>i</sub>Y<sub>i</sub>Z<sub>i</sub></i> to refer to each coordinate system, since we've decided to express the position vectors and transformation matrices in three dimensions, but I'll stick with <i>X<sub>i</sub>Y<sub>i</sub></i> for the sake of keeping things concise. If you aren't familiar with Euclidean transformations, you can read <a href="https://nrsyed.com/2017/12/03/euclidean-transformation-matrices/" rel="noopener" target="_blank">the previous post</a>.

For the 3-DOF example in this post, with its three revolute joints, we have three transformation matrices:

[latex]
\left[ ^0 T_1 \right] =
\left[ \begin{matrix} cos\theta_1 & -sin\theta_1 & 0 & x_0 \\
sin\theta_1 & cos\theta_1 & 0 & y_0 \\
0 & 0 & 1 & 0  \\
0 & 0 & 0 & 1 \end{matrix} \right]
[/latex]
<br>
[latex]
\left[ ^1 T_2 \right] =
\left[ \begin{matrix} cos\theta_2 & -sin\theta_2 & 0 & L_1 \\
sin\theta_2 & cos\theta_2 & 0 & 0 \\
0 & 0 & 1 & 0  \\
0 & 0 & 0 & 1 \end{matrix} \right]
[/latex]
<br>
[latex]
\left[ ^2 T_3 \right] =
\left[ \begin{matrix} cos\theta_3 & -sin\theta_3 & 0 & L_2 \\
sin\theta_3 & cos\theta_3 & 0 & 0 \\
0 & 0 & 1 & 0  \\
0 & 0 & 0 & 1 \end{matrix} \right]
[/latex]
<br>
where <i>[<sup>0</sup>T<sub>1</sub>]</i> is the transformation matrix to convert from the <i>X<sub>1</sub>Y<sub>1</sub></i> system to the global <i>X<sub>0</sub>Y<sub>0</sub></i> system (note that <i>x<sub>0</sub></i> and <i>y<sub>0</sub></i> are the x and y locations of the first joint in the global coordinate system), <i>[<sup>1</sup>T<sub>2</sub>]</i> is the transformation matrix to convert from the <i>X<sub>2</sub>Y<sub>2</sub></i> system to the <i>X<sub>1</sub>Y<sub>1</sub></i> system, and <i>[<sup>2</sup>T<sub>3</sub>]</i> is the transformation matrix to convert from the <i>X<sub>3</sub>Y<sub>3</sub></i> system to the  <i>X<sub>2</sub>Y<sub>2</sub></i> system. 

Finally, the coordinates of the end effector in the <i>X<sub>3</sub>Y<sub>3</sub></i> coordinate system are [latex]
\left\{ \begin{matrix} L_3 & 0 & 0 & 1 \end{matrix} \right\} ^T[/latex].

The coordinates of the end effector can be converted from the <i>X<sub>3</sub>Y<sub>3</sub></i> system to the global <i>X<sub>0</sub>Y<sub>0</sub></i> system by multiplying the transformation matrices with the end effector coordinates in the correct order:

[latex]\textbf{r}_\textbf{e} =
\left[ ^0 T_1 \right] \left[ ^1 T_2 \right] \left[ ^2 T_3 \right] \left\{ \begin{matrix} L_3 & 0 & 0 & 1 \end{matrix} \right\} ^T
[/latex]
<br>
<h1>The goal</h1>
<img src="https://nrsyed.com/wp-content/uploads/2017/12/ik_target.jpg" alt="" width="350" height="292" class="alignnone" />
<br>
Our aim is to determine how to move the end effector from its current position, <b>r<sub>e</sub></b>, to a target position, <b>r<sub>t</sub></b> (the red dot in the figure above). We'll call the difference between these <b>Δr</b>, i.e. <b>Δr</b> = <b>r<sub>t</sub></b> - <b>r<sub>e</sub></b>. Specifically, we'd like to determine how the joint angles must change for the end effector position to move by <b>Δr</b>. We'll call this change in joint angles <b>Δθ</b> (which is a vector containing all the joint angles). This change in joint angles <b>Δθ</b> is related to the change in end effector position <b>Δr</b> by the Jacobian matrix, which we'll cover in the next post.
