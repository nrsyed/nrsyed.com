In image processing and computer vision, edge detection is often a vital task. As the name suggests, edge detection refers to finding edges—that is, boundaries between regions or objects. This is not a trivial process, and there exist many techniques for finding edges. One of the earliest and most well-known approaches involves the Sobel operator, which dates back to 1968. Developed by Irwin Sobel and Gary Feldman, it is sometimes also called the Sobel-Feldman operator. The basic idea behind the Sobel operator is to quantify the rate of change of the pixel intensities throughout an image. In other words, it seeks to calculate the spatial derivative of each pixel in the image. At the boundary between objects or regions in an image, there is usually a rapid shift in pixel intensities. Consequently, the magnitude of the derivative at these boundaries tends to be relatively large. Finding the areas in an image with a large derivative can provide insight into the locations of edges and contours.

This post assumes that you already understand the concept of kernels as they relate to image processing, and also that you understand how images are represented digitally. If these concepts are not familiar to you, you should read the previous post on kernels and images:

<a href="https://nrsyed.com/2018/02/17/kernels-in-image-processing/">Kernels in image processing</a>

Furthermore, if you'd like, you can read <a href="https://www.researchgate.net/publication/239398674_An_Isotropic_3_3_Image_Gradient_Operator" rel="noopener" target="_blank">the original letter on the subject written by Irwin Sobel</a>. The short letter presents the topic far more concisely than this post. However, the goal of this post is not to be concise. Rather, it is to lay the concept (and its derivation) out in a little more detail.

<h1>Deriving the Sobel kernels</h1>
An image is not continuous but, rather, consists of distinct pixels. That means we aim to compute a discrete approximation to the derivative for each pixel. Traditionally, the Sobel technique considers a 3x3 pixel neighborhood. We can represent the pixels in this 3x3 neighborhood with the letters <i>a</i> through <i>i</i>, like so:

<img src="https://nrsyed.com/wp-content/uploads/2018/02/neighborhood_form-150x150.jpg" alt="" width="150" height="150" class="alignnone size-thumbnail wp-image-523" />

In this figure, the pixel of interest is the central pixel, pixel <i>e</i>. The other 8 pixels, <i>a, b, c, d, f, g, h</i> and <i>i</i>, are its surrounding neighborhood pixels. The goal is to approximate the derivative at <i>e</i> based on the intensities of all the pixels in the neighborhood. A spatial derivative is simply the difference in pixel intensity between two pixels divided by the distance between those pixels. If we consider the distance between directly adjacent pixels to be 1, this can be illustrated as follows:

<img src="https://nrsyed.com/wp-content/uploads/2018/02/sobel_neighborhood_square_distances-300x292.png" alt="" width="200" height="195" class="alignnone size-medium wp-image-541" />

This might be easier to visualize, geometrically, if we represent the pixel centers as nodes and the distance between them with lines:

<img src="https://nrsyed.com/wp-content/uploads/2018/02/sobel_neighborhood_cell_distances-300x300.png" alt="" width="200" height="200" class="alignnone size-medium wp-image-540" />

Then, computing the derivative of the central pixel is a matter of computing the sum of the directional derivative with respect to each of the 8 surrounding pixels:

<img src="https://nrsyed.com/wp-content/uploads/2018/02/sobel_directional_vectors-300x298.png" alt="" width="250" height="248" class="alignnone size-medium wp-image-539" />

In the figure above, the 8 directional derivatives are represented with red arrows. Note the coordinate system; by describing the pixel neighborhood with respect to an xy coordinate system, we can compute the directional derivatives in terms of their x and y components. For example, the directional derivative between the central pixel <i>e</i> and the pixel to its right, pixel <i>f</i>, is given by [latex](f-e)\pmb{\hat{\imath}}[/latex], where [latex]\pmb{\hat{\imath}}[/latex] is the unit vector in the positive x direction, and [latex]e[/latex] and [latex]f[/latex] represent the pixel intensities of pixels <i>e</i> and <i>f</i>, respectively. The directional derivative between the central pixel and the pixel to its left, pixel <i>d</i>, is given by [latex]-(d-e)\pmb{\hat{\imath}}[/latex]. Recall that the derivative is equal to the difference in pixel intensities divided by the distance between the pixels; in this case, the distance between the pairs of pixels happens to be 1.

Similarly, the directional derivative between <i>b</i> and <i>e</i> is given by [latex](b-e)\pmb{\hat{\jmath}}[/latex], where [latex]\pmb{\hat{\jmath}}[/latex] is the unit vector in the positive y direction. The directional derivative between <i>e</i> and <i>h</i> is given by [latex]-(h-e)\pmb{\hat{\jmath}}[/latex]. Again, the distance between these pairs of pixels is 1.

What about the diagonal directional derivatives? Consider the vector between <i>c</i> and <i>e</i>, which forms an isosceles right triangle whose hypotenuse has length [latex]\sqrt{2}[/latex]:

<img src="https://nrsyed.com/wp-content/uploads/2018/02/sobel_triangle_distance-150x150.png" alt="" width="150" height="150" class="alignnone size-thumbnail wp-image-542" />

Then the directional derivative, which possesses both an x and y component, is:

[latex]\frac{1}{\sqrt{2}} [(c-e)\cos45^\circ \pmb{\hat{\imath}} + (c-e)\sin45^\circ \pmb{\hat{\jmath}} ][/latex]
<br>
Recognizing that [latex]\cos45^\circ = \sin45^\circ = \frac{1}{\sqrt{2}}[/latex], we can simplify this to:

[latex]\frac{1}{2}(c-e)(\pmb{\hat{\imath}} + \pmb{\hat{\jmath}})[/latex]
<br>
Doing the same for the remaining derivatives and summing all 8, we find that the terms involving <i>e</i>, the central pixel, conveniently cancel out, leaving us with:

[latex][(f-d) + \frac{1}{2}(-a+c-g+i)]\pmb{\hat{\imath}} \\ +[(b-h) + \frac{1}{2}(a+c-g-i)]\pmb{\hat{\jmath}}[/latex]
<br>
From this, we see that summing all 8 directional derivatives produces an x component ([latex]\pmb{\hat{\imath}}[/latex]) and a y component ([latex]\pmb{\hat{\jmath}}[/latex]). If we write these out as kernels, with [latex]G_x[/latex] representing the x component and [latex]G_y[/latex] representing the y component (the derivative of a vector-valued function is also called the "gradient," which is where the "G" comes from), the kernels look like this:

<img src="https://nrsyed.com/wp-content/uploads/2018/08/sobel_G_half-250x300.png" alt="" width="250" height="300" class="alignnone size-medium wp-image-549" />

Per Sobel's original paper, because 8 pixels are used to compute the overall gradient, the kernels should be multiplied by [latex]\frac{1}{8}[/latex], resulting in a total factor of [latex](\frac{1}{8}) (\frac{1}{2}) = \frac{1}{16}[/latex]. However, traditionally, this factor is dropped, leaving the following:

<img src="https://nrsyed.com/wp-content/uploads/2018/08/sobel_G-230x300.png" alt="" width="230" height="300" class="alignnone size-medium wp-image-548" />

These are the traditionally used Sobel kernels (also known as the Sobel operator). If we wanted the actual gradients, though, we would have to include the factor of [latex]\frac{1}{2}[/latex]. Or, if we wanted the actual average gradient, we would have to include the factor of [latex]\frac{1}{16}[/latex].

The overall gradient [latex]G[/latex] for any given pixel is the magnitude of the sum of [latex]G_x[/latex] and [latex]G_y[/latex]:

[latex]G = \sqrt{G_x^2 + G_y^2}[/latex]

<h1>Visualizing the Sobel gradient</h1>

What does it look like when we actually apply the Sobel kernels to an image?  First, let's take a look at a sample source image:

<img src="https://nrsyed.com/wp-content/uploads/2018/02/original_gray.jpg" alt="" width="500" height="375" class="alignnone size-full wp-image-510" />

To detect edges via the Sobel operator, the image should generally be converted to a single channel, hence the grayscale. Furthermore, since the Sobel kernels consider only the neighboring pixels in the immediate vicinity of any given pixel, they are susceptible to noise. Consequently, a smoothing filter, like box blur or Gaussian blur, is usually applied to the original image before it's processed by the Sobel kernels. To illustrate this point, let's first observe what happens when the Sobel operator is applied to the raw image without smoothing:

<img src="https://nrsyed.com/wp-content/uploads/2018/02/sobel_no_blur.jpg" alt="" width="500" height="375" class="alignnone size-full wp-image-551" />

Not bad—notice how the edges are clearly highlighted. Still, there's a lot of noise that distracts from the real edges, particularly due to the pattern of the wood grain on the table. We can improve this somewhat by first applying a 3x3 Gaussian blur to the image:

<img src="https://nrsyed.com/wp-content/uploads/2018/02/sobel_blur.jpg" alt="" width="500" height="375" class="alignnone size-full wp-image-550" />

This is better. What if we increase the size of the Gaussian blur kernel to 5x5? The result is as follows:

<img src="https://nrsyed.com/wp-content/uploads/2018/02/sobel_blur_5x5.jpg" alt="" width="500" height="375" class="alignnone size-full wp-image-552" />

The edges are more defined still, though there appear to be diminishing returns. It should also be noted that using a Gaussian blur as opposed to a box blur, or increasing the size of the smoothing kernel, increases processing time. This may not be an issue for a single image, but can certainly be a concern for real-time video processing or for processing large batches of images. Along similar lines, note that larger Sobel kernels (e.g., 5x5) can also be implemented. The derivation for these larger Sobel kernels is slightly more involved, since there are more directional derivatives, but the approach is identical.

<h1>Conclusion</h1>
While the Sobel operator is a valuable tool for edge-detection, it is only one of several commonly used methods. Furthermore, while this technique can help isolate the edges in an image, additional processing is required to determine which edges form contours or to determine the shapes of those contours. We will likely revisit this topic again at some point, and discuss some of these other techniques.
